# Operating Systems
## 操作系统定义
- 操作系统是一个控制软件（用户）
- 资源管理，分配资源，效率最大化（内存、cpu、硬盘）
- 硬件之上，应用程序之下
- 分为外壳shell（linux，windows，android）内核kernel是操作系统的重点
## 操作系统内部组件
1. cpu调度
2. 内存管理（物理内存，虚拟和内存）
3. 终端管理
4. 磁盘管理
5. 文件管理
## 操作系统特征：
- 并发（一段时间） 并行（一个时间点，一般多个cpu）
- 共享
- 虚拟
- 异步
## 计算机工作原理
![计算机](./pics/operation%20system/计算机体系.png)
- 代码放到内存中，控制器自动取地址进行执行（取址执行）
- BIOS base input output system
- X86 intel架构
- 32位一次计算4个字节，64位一次计算8个字节
- 32位的cpu最大寻址空间为4G，cpu操作4G内存，需要32条地址总线 2的32次方=4G
- 64位指令很难在32位机器上运行，因为32位的寄存器存不下64位的指令
- cpu（控制单元，寄存器，逻辑运算单元） 总线（控制总线，数据总线，内存总线）
- 存储器：寄存器——>CPU L1/L2/L3 Cache    
- L1 Cache和L2 Cache是每个cpu核心独有的，而L3 Cache是多个cpu核心共享的    
  
![存储器](./pics/operation%20system/存储层级.png)    

![cpu层级](./pics/operation%20system/cpu层级.png)
提升程序的效率的路径之一：数据缓存和指令缓存的缓存命中率
### cpu Cache的一致性

![cpu层级](./pics/operation%20system/cpu缓存一致性.png)
- 写直达，直接把数据同时写入内存和Cache中
- 写回：当发⽣写操作时，新的数据仅仅被写⼊ Cache Block ⾥，只有当修改过的Cache Block「被替换」时才需要写到内存中，如果缓存命中，只将该数据写到Cache中，并标记为脏。
- 缓存一致性，当一个cpu中有多个核心时，L1和L2 Cache是各自独有的，因此要保持缓存的一致性
  1. 写传播：当某个核心的缓存更新时，必须传播到其他核心的Cache
  2. 串行化
- MESI协议
  Cache的四个状态：
  1. Modified（已修改）：已被更新过，没被写到内存
  2. Exclusive（独占）
  3. Shared（共享）
  4. Invalidated（已失效）不可读取该状态的数据
- 独占和共享数据都是干净的，和内存中一致，独占只有一个核心中有数据，共享是所有核心的数据相同
- 已修改和独占时不需要广播     

![mesi](./pics/operation%20system/mesi.png)
- 伪共享：两个进程绑定两个cpu的核心，A进程获取A数据，B进程获取B数据，但是AB在内存中被读取到同一个cache line中，当A读取，CL变成独占，B读取，AB变成共享，A修改，B变成已失效，A写入，变成已修改。B要修改时，需要A先写入到内存，然后才能修改B。所以就出现了缓存并未起作用的情况
- 如何避免伪共享？避免数据在同一Cache Line中，对齐cache line，字节填充
### 中断
![中断](./pics/operation%20system/中断.png)
- 中断是指操作系统收到硬件的中断请求，打断正在执行的进程，调用内核中的中断处理程序来响应请求。异步处理机制，提高并发能力。   
中断处理过程：
  1. 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。
  2. 开中断：以便执行中断时能响应较高级别的中断请求。
  3. 中断处理
  4. 关中断：保证恢复现场时不被新中断打扰
  5. 恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。
- 软中断：中断请求的处理程序要求短且快，因此将中断分为两部分，
    1. 上半部分用来快速处理中断，硬中断（打断cpu正在执行的任务）。主要是负责耗时短的⼯作，特点是快速执⾏；
    2. 下半部分处理上半部分未完成的工作，内核触发。耗时多，延迟执行。
- 复数用补码表示（正数的二进制全部取反再加1）
### windows and Linux
- 内核是连接应用和硬件设备，cpu，内存的桥梁
- 内核的基本功能
  1. 管理进程线程，选择调度进程使用cpu
  2. 管理内存分配和和回收
  3. 管理硬件设备，与硬件通信
  4. 提供系统调用：用户程序与操作系统之间的接口
- 内存被分为两个区域：
  1. 内核空间，内核程序访问  内核态 
  2. 用户空间，应用程序访问  用户态
- linux采用宏内核，系统的所有模块都是在内核态下运行
- 鸿蒙微内核，只保留最基本的能力，进程调度，虚拟机内存，中断等，驱动，文件系统放在用户空间
- windows是混合型内核，内核里有个最小版本的微内核，宏内核中包含一个微内核。
## 内存管理
![内存管理](./pics/operation%20system/内存管理.png)   
单片机上的cpu直接操作内存（物理地址）
### 虚拟内存 
  1. 为了不同的进程同时进行，给每个进程分配一套虚拟内存，操作系统提供将不同进程的虚拟地址和不同的内存的物理地址映射起来的机制
  2. 进程持有的虚拟地址会通过cpu中的内存管理单元映射，转化为物理地址，通过物理地址访问内存
  3. 操作系统管理映射：内存分段，内存分页，段页式
### 内存分段（segmentation）
  1. 虚拟地址由段选择子和段内偏移量组成
  2. 段选择子中段号用作段表的索引，段表中保存段的基地址，段的界限和特权等级
  3. 先查段表，通过基地址加上偏移量找到物理地址
- 内存分段的问题
  1. 内存碎片问题，外部内存存在连续的小物理内存；所有的内存都被装载到物理内存，但有部分不经常使用
  2. 内存交换的效率低。解决内存碎片问题利用内存交换（先存硬盘，耗时）
### 内存分页
  1. 分页式把整个虚拟和物理内存空间切成一段段固定尺寸的大小。连续且固定尺寸的内存空间叫页（linux下每一页4kb）
  2. 分页解决分段内存碎片化和内存交换效率低的问题
  3. 换入换出：内存不够，把最近不用的内存写到硬盘，一旦需要再写入。一次性写的页不多，因此内存交换的效率相对较高。
  4. 页表在内存中，进程访问的虚拟地址，查不到页表时，系统产生缺页异常（系统内核空间分配物理内存，更新页表，返回用户空间，恢复进程）
  5. 实际上只有在程序运行中，需要取对应虚拟内存页里的数据和指令时，才加载到物理内存中

![分页](./pics/operation%20system/分页.png)
1. 虚拟内存切成页号和偏移量
2. 根据页号，从页表查询对应的物理页号
3. 拿到物理页号，加上前面的偏移量，得到物理内存地址
### 内存分页的缺陷和解决办法
问题：32位的环境每个页4K,4GB需要4MB空间存储，100个进程需要400MB存储页表   
解决方法：多级页表
![二级页表](./pics/operation%20system/二级页表.png)
- 32位和页大小为4KB的情况下，分成10位一级页号（2的10次方=1024），10位二级页号（包含1024个页表项），12位偏移
- 局部性原理：
    1. 如果某个⼀级⻚表的⻚表项没有被⽤到，也就不需要创建这个⻚表项对应的⼆级⻚表了，即可以在需要时才创建⼆级⻚表
    2. ⻚表⼀定要覆盖全部虚拟地址空间，不分级的⻚表就需要有 100 多万个⻚表项来映射，⽽⼆级分⻚则只需要 1024 个⻚表项
### 段页式内存管理
- 先将程序划分成多个有逻辑意义的段，再把每个段分成页
- 地址变成，段号，段内页号，页内偏移
![段页式](./pics/operation%20system/段页式.png)
访问方式：   
1. 第一次访问段表，得到页表起始地址
2. 第二次访问页表，得到物理页号
3. 第三次物理页号+页内位移，得到物理地址
### linux采用分页管理
Linux 系统中虚拟空间分布可分为⽤户态和内核态两部分，其中⽤户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。
## 进程
![进程和线程](./pics/operation%20system/进程和线程.png)
- 多个程序，交替执行，由于时间较短，实现并发
- 并行和并发
  1. 并行是指两个核同时分别处理两个任务
  2. 并发是指两个任务交替进行，但由于时间短，看起来像是同时进行的
- cpu从一个进程切换到另一个进程，切换前需要记下此时进程的运行状态，以备下次切换回来可以恢复执行       

![完整进程](./pics/operation%20system/完整进程.png)
- 当有大量阻塞会浪费内存，所以增加一个挂起状态：描述没有占用内存(将物理内存空间换出到硬盘)
- PCB是进程存在的唯一标识。PCB包含进程描述信息，控制信息，资源分配，cpu相关信息
- PCB通过链表组织在一起，组成队列。为什么选择链表，为了方便插入进程和删除进程
### 进程的控制 创建——》终止——》阻塞——》唤醒
- 创建：分配PCB,进入就绪队列
- 终止：查找终止PCB，如果有子进程，也需要终止，删除PCB,归还资源
- 阻塞：进程需要等待某一时间完成，调用阻塞语句把自己阻塞，一但阻塞，只能由另一个进程唤醒
- 唤醒：有阻塞，就会有唤醒。自己阻塞，别人唤醒。

### 进程上下文切换
一个任务包含进程，线程，和中断，对应出现进程上下文切换，线程上下文切换，中断上下文切换
- 操作系统帮CPU设置好CPU寄存器和程序计数器（存储指令位置和下一条指令位置）
- 发生进程切换的场景：时间片耗尽，运行变就绪，执行其他进程；内存不足，挂起；主动挂起；硬件中断；优先级更高的程序进来

### 进程间的通信方式
![进程间通信](./pics/operation%20system/进程间通信.png)
每个进程的用户空间独立，内核空间每个进程共享，通信通过内核
- 管道，半双工方式。匿名管道（存在父子进程的之间）和命名管道（先进先出）
- 消息队列：用户态把消息保存在内核中的消息链表，由另一进程读取到用户态。通信不及时，不适合大数据，存在用户态与内核态的数据拷贝开销。
- 共享内存。每个进程都有自己的虚拟内存，共享内存就是拿出一块虚拟地址空间，映射到相同的物理内存中。
- 信号量。 整型的计数器。用于实现进程间的互斥和同步。PV操作。
- 信号。
- Socket，跨主机进程通信。
- 
## 线程
线程是进程中的一条执行流程。是CPU调度的单位。
- 优点：
  1. 一个进程同时存在多个线程
  2. 各个线程并发执行
  3. 各个线程之间可以共享地址空间和文件等资源
- 缺点：
  1. 一个线程崩溃，导致进程崩溃
- **进程和线程的区别**
  1. 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
  2. 切换：线程上下文切换比进程上下文切换要快得多。
  3. 拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
  4. 系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。
- 线程上下文切换时：
  1. 当两个线程不是属于同一个进程，跟切换进程上下文一致
  2. 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据
- 线程的实现
  1. 用户线程：用户空间实现的  多对一，多个用户线程对应一个内核线程
  2. 内核线程：内核管理的线程  一对一，一个用户线程对应一个内核线程
  3. 轻量级线程：在内核中来支持用户线程；  多对多 多个用户线程对应多个内核线程
---
### 进程调度
从一个状态变到另一个状态   
原则：cpu利用率，系统吞吐量，周转时间，等待时间，响应时间   
单核CPU调度算法：    
1. 先来先服务： 先进入就绪队列的先执行
2. 最短作业优先： 优先选择运行时常短的进程执行
3. 相应比有限调度算法。先计算优先级，再挑选最高的进程投入运行。优先权=（等待时间+要求服务时间）/要求服务时间
4. 时间片轮转调度算法：每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行
5. 最高优先级调度算法
6. 多级反馈队列调度算法：有多个就绪队列，每个队列优先级从高到低，优先级越高时间片越短

### 多线程冲突
![线程冲突](./pics/operation%20system/线程冲突.png)
cpu时间调度和虚拟内存造成并发  
如果一个程序只有一个执行流程，也代表它是单线程的。当然一个程序可以有多个执行流程，也就是所谓的多线程程序，线程是调度的基本单位，进程则是资源分配的基本单位。   
线程之间是可以共享进程的资源，比如代码段、堆空间、数据段、打开的文件等资源，但每个线程都有自己独立的栈空间。     
当多个线程竞争共享资源时，造成共享数据的混乱。    
- 临界区：互斥的。当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操作共享资源的目的。   
- 同步：就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。
- 锁。
- 信号量。在执行临界资源前调用P操作，在访问完临界资源后，调用V操作。
  1. 互斥操作。sem初始为1；当一个线程想进入临界区，执行P : sem - 1 = 0；表示空闲。当第二个进来，执行P操作，sem < 0,表示资源已经被占用，进入堵塞，第一个结束后，进行V操作，sem + 1，唤醒第二个线程
  2. 同步操作。sem初始为0。
- 生产者-消费者问题。  
  
### 死锁
两个线程为了保护两个不同的共享资源而使用了两个互斥锁，应用不当时，两个线程都在等待对方释放锁，导致线程一直等待。
- 死锁的四个必要条件
  1. 互斥条件：一个资源一次只能被一个进程使用
  2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
  3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
  4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系
- 常用的处理死锁的方法：（破坏其中的一个条件，一般资源有序分配法来破坏环路的等待条件）死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略。     

![锁](./pics/operation%20system/锁.png)
加锁的目的时保证共享资源在任意时间里，只有一个线程访问
- 互斥锁和自旋锁
  1. 互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
  2. 自旋锁加锁失败后，线程会忙等待，直到它拿到锁；
- 读写锁：读多写少的情况
- 乐观锁和悲观锁。
  1. 悲观锁认为并发访问资源时，冲突概率很高，所以访问前需要加锁
  2. 先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。Git，在线文档
- 互斥锁、自旋锁、读写锁都是悲观锁。
## 调度算法
![调度算法](./pics/operation%20system/调度算法.png)
### 进程调度算法 cpu调度算法
- 当进程状态发生转换时，发生cpu调度
  1. 运行——>等待
  2. 运行——>就绪  时间片用完，中断，占用cpu
  3. 等待——>就绪  等待的优先级高，一旦完成等待，立马就绪，就会被cpu调度
  4. 运行——>终止
- 非抢占式调度（1，4）抢占式调度（2，3）
- 进程调度算法：
  1. 先到先服务（队列）
  2. 最短作业优先法（执行耗时最短的）
  3. 响应比优先调度法
  4. 时间片轮转算法
  5. 最高优先级调度算法 （抢占式，非抢占式）
  6. 多级反馈队列调度算法
### 内存页面置换算法
- 缺页异常（中断）
  1. 当CPU访问的物理页面不在物理内存时，会产生一个缺页中断，请求操作系统将所缺页面调入到物理内存。
  2. 页面置换算法的功能是，当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页
  3. 页面置换算法的目标是：尽可能减少也买你的换入换出的次数
- 最佳页面置换算法 （置换在「未来」最长时间不访问的页面）
- 先进先出置换算法
- 最近最久未使用的置换算法
- 时钟页面置换算法
- 最不常用置换算法
### 磁盘调度算法
- **磁盘调度时最耗时的是寻道时间。**
- 先来先服务
- 最短寻道时间优先
- 扫描算法 每次选定一个方向
- 循环扫描法 每次扫描完，复位重新扫描
## 文件系统
![文件系统](./pics/operation%20system/文件系统.png)
一切皆文件。
