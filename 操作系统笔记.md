# Operating Systems
## 操作系统定义
- 操作系统是一个控制软件（用户）
- 资源管理，分配资源，效率最大化（内存、cpu、硬盘）
- 硬件之上，应用程序之下
- 分为外壳shell（linux，windows，android）内核kernel是操作系统的重点
## 操作系统内部组件
1. cpu调度
2. 内存管理（物理内存，虚拟和内存）
3. 终端管理
4. 磁盘管理
5. 文件管理
## 操作系统特征：
- 并发（一段时间） 并行（一个时间点，一般多个cpu）
- 共享
- 虚拟
- 异步
## 计算机工作原理
![计算机](./pics/operation%20system/计算机体系.png)
- 代码放到内存中，控制器自动取地址进行执行（取址执行）
- BIOS base input output system
- X86 intel架构
- 6.77-1.48+16.95
- 32位一次计算4个字节，64位一次计算8个字节
- 32位的cpu最大寻址空间为4G，cpu操作4G内存，需要32条地址总线 2的32次方=4G
- 64位指令很难在32位机器上运行，因为32位的寄存器存不下64位的指令
- cpu（控制单元，寄存器，逻辑运算单元） 总线（控制总线，数据总线，内存总线）
- 存储器 寄存器——>CPU L1/L2/L3 Cache    
- L1 Cache和L2 Cache是每个cpu核心独有的，而L3 Cache是多个cpu核心共享的    
  
![存储器](./pics/operation%20system/存储层级.png)    

![cpu层级](./pics/operation%20system/cpu层级.png)
提升程序的效率的路径之一：数据缓存和指令缓存的缓存命中率
### cpu Cache的一致性

![cpu层级](./pics/operation%20system/cpu缓存一致性.png)
- 写直达，直接把数据同时写入没存和Cache中
- 写回：当发⽣写操作时，新的数据仅仅被写⼊ Cache Block ⾥，只有当修改过的Cache Block「被替换」时才需要写到内存中，如果缓存命中，只将该数据写到Cache中，并标记为脏。
- 缓存一致性，当一个cpu中有多个核心时，L1和L2 Cache是各自独有的，因此要保持缓存的一致性
  1. 写传播：当某个核心的缓存更新时，必须传播到其他核心的Cache
  2. 串行化
- MESI协议
  Cache的四个状态：
  1. Modified（已修改）：已被更新过，没被写到内存
  2. Exclusive（独占）
  3. Shared（共享）
  4. Invalidated（已失效）不可读取该状态的数据
- 独占和共享数据都是干净的，和内存中一致，独占只有一个核心中有数据，共享是所有核心的数据相同
- 已修改和独占时不需要广播     

![mesi](./pics/operation%20system/mesi.png)
- 伪共享：两个进程绑定两个cpu的核心，A进程获取A数据，B进程获取B数据，但是AB在内存中被读取到同一个cache line中，当A读取，CL变成独占，B读取，AB变成共享，A修改，B变成已失效，A写入，变成已修改。B要修改时，需要A先写入到内存，然后才能修改B。所以就出现了缓存并未起作用的情况
- 如何避免伪共享？避免数据在同一Cache Line中，对齐cache line，字节填充
### 中断
![中断](./pics/operation%20system/中断.png)
- 中断是指操作系统收到硬件的中断请求，打断正在执行的进程，调用内核中的中断处理程序来响应请求。异步处理机制，提高并发能力。
- 软中断：中断请求的处理程序要求短且快，因此将中断分为两部分，
    1. 上半部分用来快速处理中断，硬中断（打断cpu正在执行的任务）。主要是负责耗时短的⼯作，特点是快速执⾏；
    2. 下半部分处理上半部分未完成的工作，内核触发。耗时多，延迟执行。
- 复数用补码表示（正数的二进制全部取反再加1）
### windows and Linux
- 内核是连接应用和硬件设备，cpu，内存的桥梁
- 内核的基本功能
  1. 管理进程线程，选择调度进程使用cpu
  2. 管理内存分配和和回收
  3. 管理硬件设备，与硬件通信
  4. 提供系统调用：用户程序与操作系统之间的接口
- 内存被分为两个区域：
  1. 内核空间，内核程序访问  内核态 
  2. 用户空间，应用程序访问  用户态
- linux采用宏内核，系统的所有模块都是在内核态下运行
- 鸿蒙微内核，只保留最基本的能力，进程调度，虚拟机内存，中断等，驱动，文件系统放在用户空间
- windows是混合型内核，内核里有个最小版本的微内核，宏内核中包含一个微内核。
## 内存管理
![内存管理](./pics/operation%20system/内存管理.png)
单片机上的cpu直接操作内存（物理地址）
### 虚拟内存 
  1. 为了不同的进程同时进行，给每个进程分配一套虚拟内存，操作系统提供机制将不同进程的虚拟地址和不同的内存的物理地址映射起来
  2. 进程持有的虚拟地址回通过cpu中的内存管理单元映射，转化为物理地址，通过物理地址访问内存
  3. 操作系统管理映射：内存分段，内存分页，段页式
### 内存分段（segmentation）
  1. 虚拟地址由段选择子和段内偏移量组成
  2. 段选择子中段号用作段表的索引，段表中保存段的基地址，段的界限和特权等级
  3. 先查段表，通过基地址加上偏移量找到物理地址
- 内存分段的问题
  1. 内存碎片问题，外部内存存在连续的小物理内存；所有的内存都被装载到物理内存，但有部分不经常使用
  2. 内存交换的效率低。解决内存碎片问题利用内存交换（先存硬盘，耗时）
### 内存分页
  1. 分页式把整个虚拟和物理内存空间切成一段段固定尺寸的大小。连续且固定尺寸的内存空间叫页（linux下每一页4kb）
  2. 分页解决分段内存碎片化和内存交换效率低的问题
  3. 换入换出：内存不够，把最近不用的内存写到硬盘，，一旦需要再写入。一次性写的页不多，因此内存交换的效率相对较高。
  4. 页表在内存中，进程访问的虚拟地址，查不到页表时，系统产生缺页异常（系统内核空间分配物理内存，更新页表，返回用户空间，恢复进程）
  5. 实际上只有在程序运行中，需要取对应虚拟内存页里的数据和指令时，才加载到物理内存中

![分页](./pics/operation%20system/分页.png)
1. 虚拟内存切成页号和偏移量
2. 根据页号，从页表查询对应的物理页号
3. 拿到物理页号，加上前面的偏移量，得到物理内存地址
### 内存分页的缺陷和解决办法
问题：32位的环境每个页4K,4GB需要4MB空间存储，100个进程需要400MB存储页表   
解决方法：多级页表
![二级页表](./pics/operation%20system/二级页表.png)
- 32位和页大小为4KB的情况下，分成10位一级页号（2的10次方=1024），10位二级页号（包含1024个页表项），12位偏移
- 局部性原理：
    1. 如果某个⼀级⻚表的⻚表项没有被⽤到，也就不需要创建这个⻚表项对应的⼆级⻚表了，即可以在需要时才创建⼆级⻚表
    2. ⻚表⼀定要覆盖全部虚拟地址空间，不分级的⻚表就需要有 100 多万个⻚表项来映射，⽽⼆级分⻚则只需要 1024 个⻚表项
### 段页式内存管理
- 先将程序划分成多个有逻辑意义的段，再把每个段分成页
- 地址变成，短号，段内页号，页内偏移
![段页式](./pics/operation%20system/段页式.png)
访问方式：   
1. 第一次访问段表，得到页表起始地址
2. 第二次访问页表，得到物理页号
3. 第三次物理页号+业内位移，得到物理地址
### linux采用分页管理
Linux 系统中虚拟空间分布可分为⽤户态和内核态两部分，其中⽤户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。
## 进程与线程
