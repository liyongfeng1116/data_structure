# 面经
## 招银网络
1. 怎么管理登录状态？
2. java锁
   乐观锁和悲观锁
   乐观锁默认在使用数据时不会被别的线程修改，只有在更新的时候才会看看之前有没有被别的线程修改过。适合读操作。
   悲观锁默认自己在使用数据时，一定会被别的线程操作，因此在获取数据时加锁。保证不会被其他线程修改。synchronized关键字和Lock的实现类都是悲观锁。
   公平锁和非公平锁
   公平锁按照多个线程申请锁的顺序，先到先排队服务，队首线程先获得锁。（各个锁不会饿死，但除第一个锁，其他的都会阻塞，需要cpu唤醒线程）
   非公平锁时在多个线程加锁时直接尝试获取锁，如果此时锁可用，该线程直接无阻塞获取到锁。（插队，减少唤醒线程的开销，但可能等待队列中的线程会被饿死）
   可重入锁和非可重入锁
   可重入锁，又名递归锁。指同一个线程在外层函数获取到锁后，进入该线程的内层方法，如果锁对象是同一个对象或者类，会自动获取锁。ReentrantLock和synchronized锁都是可重入锁。
   独享锁和共享锁
   排它锁，该锁只能被一个线程所持有。如果线程T对A数据加独享锁，那线程B不能再操作它，独享锁可以读也可以修改数据。
   共享锁，指锁可以被多个线程共同持有。加了共享锁的数据，其他线程也可以加共享锁，但不能加独享锁。
   自旋锁和适应性自旋锁
   阻塞或唤醒线程需要操作系统从用户态切换到内核态，该状态转换需要处理器时间，线程尝试获取锁，发现被占用后，不放弃cpu执行时间，不进入阻塞状态，而是循环重试，重试到指定次数，进入阻塞。那么当前线程就可以不用阻塞直接获取同步资源。从而避免线程切换带来的开销。
   锁升级
   阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长
    锁的四种状态：
    无锁，偏向锁，轻量级锁状态，重量级锁状态。
    偏向锁，一般不会碰到竞争，所以看看是不是自己在用，是的话就一直用
    轻量级锁，竞争不激烈，分时段竞争，自旋一下就能得到，没必要阻塞
    重量级锁，mutex，阻塞队列，默认自旋
    锁升级的步骤：
    1. 检查Mark word里面检查是不是当前线程的ID，如果是，表示当前线程处于偏向锁
    2. 如果不是，则用CAS将当前线程的ID替换Mark Word，如果成功则表示当前线程获得偏向锁，置偏向标志位为1。
    3. 如果失败，说明存在竞争，撤销偏向锁，进而升级为轻量级锁。
    4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得轻量级锁
    5. 如果失败，说明其他线程竞争锁，当前线程自旋来获取锁。
    6. 如果自旋成功，依旧处于轻量级状态。
    7. 自旋失败，升级为重量级锁。
    CAS机制（compare and swap）在更新前，线程工作区的值先和内存中的值进行比较，如果一致，新值替换原来值，不一致，重新获取工作区的值（自旋）。CAS保证变量原子性，对于代码块用synchronized。
    
3. java关键字 volatile 
   java提供的一种轻量型的同步机制。
   java包含两种同步机制：同步方法和volatile变量。
   synchronized是重量级锁，volatile是轻量级，不会引起线程上下文转换。
   volatile三大特性（1.保证可见性，2.不保证原子性，3.有序性）
   JMM即java内存模型，只是一种虚拟规范。每个线程创建并非操作主内存，而是将主内存的数据拷贝一份到自己工作内存，由于不同的线程不能访问对方的工作内存。因此一个线程修改了主内存的值，为了保证其他线程能够知道，使用volatile。
   volatile的应用场景：单例模式
   synchronized不加在方法上，因为太重了
   当AB两个线程都创建对象Type时，都通过了第一次检查，A如果先进来，创建对象成功，把该对象同步到主内存；B被放进来，但由于B线程没有及时同步主内存，因此B会又new一个对象。用volatile修饰后，根据可见性即可解决。
   ```
   // 安全的双重检查的单例模式
   public class Type {
        private static volatile Type type; // 类变量，用static和volatile修饰。

        private Type() {} // 构造方法

        public static Type getInstance() {
            if (type == null) {
                synchronized(type.class) { // 不给方法加锁，太重了
                    if (type == null) {
                        type = new Type();
                    }
                }
            }
            return type;
        }

   }
   ```
4. java 关键字 synchronized
    synchronized是一个java同步关键字，是可重入，独享，非公平，悲观的同步锁。主要用在多线程时数据不安全。
    修饰同步方法：锁对象是当前实例
    修饰静态方法：锁对象是当前类Class对象
    修饰同步代码块：括号后面配置的对象或类
    修饰非静态方法和代码块时，因为同一类的不同对象拥有自己的锁，所以不会阻塞。
5. 代理模式有几种？（设计模式）
   静态代理，动态代理和Cglib代理
6. ConcurrentHashMap？（collection集合）
   集合：Collection（List, Queue, Set）
   线程安全的：Vector，HashTable，ConcurrentHashMap
7. 数据库MVCC多版本并发控制
8. 聚簇索引：
   聚簇索引叶子节点存储的是实际数据，非聚簇索引存的是主键id
9.  手撕代码：快排找K